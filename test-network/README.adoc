= OpenJML-Wrapped Chaincode-As-A-Service Test Network Configuration
2023-07-10
:toc:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:cc-pkg-dir: chaincode-package/
:cc-name: tpcc

== USAGE

.Prerequisites
Make sure you have `docker` available (with `compose`, of course).
Note that `fablo` generates scripts that require the legacy `docker-compose` to exist in your `PATH`, so if you are using https://docs.docker.com/compose/migrate/[Compose V2], just place a wrapper binary (script) somewhere in your `PATH`.

.Instructions
. Normally, all you need to do is execute `$ ./fabric-docker.sh up` (or `$ ./fabric-docker.sh reset` if you have already ``up``’ed once)
** This should…
*** spin up a small local network with a single peer in a single organization (`org1`) and a single orderer (in a separate organization),
*** generate all crypto material automatically and transparently (you never need to see it),
*** create a channel named `my-channel1`,
*** start an external chaincode container called `{cc-name}`
*** install the chaincode definition (package) for `{cc-name}`,
*** and start some https://github.com/fablo-io/fablo-rest[Fablo REST] endpoints.
. Then you can proceed to try calling the chaincode as described below

IMPORTANT: If you have made changes to the chaincode, pass the `-b` or `--build` flag to `fabric-docker.sh up` or `fabrid-docker.sh reset`, otherwise the chaincode image will not be rebuilt.

.Invoking the chaincode
====
You should use the REST endpoints according to https://github.com/fablo-io/fablo-rest[Fablo REST’s] documentation.
That is, first generate a token using the credentials `admin/adminpw` at ``org1``’s REST API, then invoke the chaincode using that token and the appropriate parameterization.

I am using https://httpie.io/[HTTPie] and https://jqlang.github.io/jq/[`jq`], but you can also do this with `curl` and other command line / GUI tools.
Note that the command line outputs have been altered to make them more concise.

First, call the `/user/enroll` endpoint to get a bearer token (the default credentials are `admin/adminpw`) and save it in a variable `token`:

----
$ token=$(http http://localhost:8801/user/enroll id=admin secret=adminpw | jq .token | tr -d '"')
----

Then you can invoke the chaincode with the received token to invoke the chaincode, like so:

----
$ http -v -A bearer -a $token http://localhost:8801/invoke/my-channel1/tpcc method=initEntries args:='[]'
POST /invoke/my-channel1/notes HTTP/1.1
Accept: application/json, */*;q=0.5
Accept-Encoding: gzip, deflate
Authorization: Bearer ba945b10-0253-11ee-b51b-5b5e65097fa0-admin
Content-Type: application/json

{ "args": [], "method": "initEntries" }

HTTP/1.1 200 OK

{ "response": "" }
----
====


== MORE DETAILS

[TIP]
When developing the chaincode, you most likely do not need to make modifications to anything described here.
Fablo (with our customizations) should hide these details from you.

.Subdirectories & Files
* link:{cc-pkg-dir}/[`chaincode-package/`]: contains (with instructions to regenerate) a `{cc-name}.tgz` chaincode package, ready to install on Fabric peers (as external Chaincode-As-A-Service)
* link:fabric-config/[`fabric-config/`]: has been generated by `fablo`; you probably do not need to worry about anything here
* link:fabric-docker/[`fabric-docker/`]: has been generated by `fablo`; some files have been modified to support installing chaincode as an external servicefootnote:[Namely, the `commands-generated.sh` file has a custom function for this purpose]
* link:fabric-docker.sh[`fabric-docker.sh`]: script generated by `fablo` to manage the test network; refer to `$ ./fabric-docker.sh help` on how to use the script

Some subdirectories have their own _README_ files where you can learn more.

[qanda]
WHEN to regenerate the chaincode package `{cc-name}.tgz`?::
This file only needs to be regenerated if the contents of link:{cc-pkg-dir}/connection.json[`connection.json`] or link:{cc-pkg-dir}/metadata.json[`metadata.json`] change.
These files contain data such as the _name_ of the chaincode container, the TCP _port_ it listens on.

HOW to regenerate the chaincode package `{cc-name}.tgz`?::
There is a link:{cc-pkg-dir}/scripts/package[`package`] script that recreates the gzipped tarball.
Beware that recreating the package _changes the package ID which then has to be updated in several places._
The full process is the following:
. Make your changes to link:{cc-pkg-dir}/connection.json[`connection.json`] and link:{cc-pkg-dir}/metadata.json[`metadata.json`]
. Run link:{cc-pkg-dir}/scripts/package[`package`] to regenerate `{cc-name}.tgz` (from the link:{cc-pkg-dir}[`{cc-pkg-dir}`] directory!)
. Run link:{cc-pkg-dir}/scripts/copy-to-fablo[`copy-to-fablo`] (from the link:{cc-pkg-dir}[`{cc-pkg-dir}`] directory!) to recalculate the package ID for the new package and copy it to the appropriate directory that is mounted to the containers at runtime; the script prints the package ID on the standard output, _MAKE NOTE OF IT!_
. Replace every occurrence of the previous package ID with the new one.  Known locations:
** link:fabric-docker/docker.compose.yaml[`docker.compose.yaml`]: in the chaincode container service (`{cc-name}`)
** link:fabric-docker/commands-generated.sh[`commands-generated.sh`]: present multiple times, make sure to replace each
** _The safest way is to recursively `grep` for the old package ID, eg by issuing `$ grep -RFInC1 thisisthepackageida03d5726c28a155d993f6789701908d88746d0e5f0c9078860a7b4ae18411886` from the root of the repository_
